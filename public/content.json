{"pages":[{"title":"书单","date":"2018-08-09T09:54:26.000Z","updated":"2018-07-30T18:55:52.000Z","comments":false,"path":"books/index.html","permalink":"blog.lookpeakfans.xyz/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-09-13T06:44:06.000Z","updated":"2018-09-13T06:44:06.000Z","comments":false,"path":"about/index.html","permalink":"blog.lookpeakfans.xyz/about/index.html","excerpt":"","text":"致力于小程序、微信公众号与web前端开发。喜欢新事物，关注前端动态，对新的技术有追求；努力学会做一个”懒人”。&#123; name: 'lishaohua' age: 24, gender: '男', profession: 'Web Developer', experience: '3年', address: '北京市朝阳区', education: '本科', github: 'https://github.com/Andrew-project', blog: 'blog.lookpeakfans.xyz', email: 'lsh294753@gmail.com', description: '致力于小程序、微信公众号与web前端开发', skills: [ ['Html', 'Javascript', 'CSS', 'ES6', 'Node', 'Typescript'], ['Less','Sass'], ['Angular', 'Ionic'], ['小程序', '微信公众号'], ['Vue'], ['Git'], ['NG-ZORRO', 'Bootstrap'] ], devTools: [ ['Visual Studio Code', 'Webstorm'], ['Chrome DevTools'], ] &#125;"},{"title":"分类","date":"2018-08-09T09:54:26.000Z","updated":"2018-07-30T18:55:52.000Z","comments":false,"path":"categories/index.html","permalink":"blog.lookpeakfans.xyz/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-08-09T09:54:26.000Z","updated":"2018-07-30T18:55:52.000Z","comments":true,"path":"links/index.html","permalink":"blog.lookpeakfans.xyz/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-08-09T09:54:26.000Z","updated":"2018-07-30T18:55:52.000Z","comments":false,"path":"repository/index.html","permalink":"blog.lookpeakfans.xyz/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-09T10:21:42.000Z","updated":"2018-08-09T10:21:42.000Z","comments":false,"path":"tags/index.html","permalink":"blog.lookpeakfans.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"将博客搬至CSDN","slug":"csdn","date":"2019-03-14T16:00:00.000Z","updated":"2019-03-21T03:29:12.672Z","comments":true,"path":"2019/03/15/csdn/","link":"","permalink":"blog.lookpeakfans.xyz/2019/03/15/csdn/","excerpt":"","text":"此地址与CSDN内容同步更新","categories":[{"name":"文章","slug":"文章","permalink":"blog.lookpeakfans.xyz/categories/文章/"}],"tags":[{"name":"个人","slug":"个人","permalink":"blog.lookpeakfans.xyz/tags/个人/"}]},{"title":"与小程序的相爱相杀","slug":"wechat-applet","date":"2018-09-11T16:00:00.000Z","updated":"2018-09-12T08:27:50.000Z","comments":true,"path":"2018/09/12/wechat-applet/","link":"","permalink":"blog.lookpeakfans.xyz/2018/09/12/wechat-applet/","excerpt":"","text":"Q1：自定义组件时，canvas组件无法注册ready()&#123; const ctx = wx.createCanvasContext('back-canvas') ctx.setFillStyle('red') ctx.fillRect(10, 10, 150, 75) ctx.draw(); &#125;&lt;canvas class='canvas' canvas-id=\"back-canvas\" style=\"width:200px;height:200px;\"&gt;&lt;/canvas&gt;// createCanvasContext方法是有两个参数的，在page页面默认传了一个this,组件里面 需要手动传thisconst ctx = wx.createCanvasContext('myCanvas',this);Q2：使用image标签的binderror方法，避免图片URL无效Q3：生命周期onLoad只加载一次只是对页面不属于栈顶有效，如果页面属于栈顶，则页面onLoad会随页面加载多次Q4：选择拍照功能和相册选择图片，原有的页面会onHideQ5：margin-bottom在iOS环境下无效，建议改成padding-bottomQ6：wx.createInnerAudioContext()播放语音先try销毁再新建Q7：小程序console过多报错: 转Uncaught TypeError: Converting circular structure to JSON解决办法： 注释掉console.logQ8：setNavigationBarTitle动态异步设置title存在bug，目前官方正在解决中…Q9：wxs文件解决wxml中不能写计算逻辑问题Q10：setData修改数组某一项值时可以不用全局赋值var price = &apos;goods[&apos;+index+&apos;].price&apos;this.setData(&#123; [price]:&apos;changed data&apos;&#125;)Q11：微信小程序超级大坑之40029（invalid code）在小程序新建的时候就应该输入你正式的AppID，如果使用修改的AppID，则无法使用。jscode2session会返回&#123;\"errcode\":40029,\"errmsg\":\"invalid code, hints: [ req_id: m3yw8a0472th20 ]\"&#125;不能通过修改project.config.json中的AppID来实现：必须重新创建新的小程序项目。Q12：web-view会自动修改导航栏标题 (暂无方案)Q13：小程序里修改swiper指示点位置居右.wx-swiper-dots.wx-swiper-dots-horizontal&#123; position:absolute; right:0rpx; padding-right: 30rpx; text-align: right; width: 100%;&#125;Q14：iOS上new Date()出现NAN情况Android: +new Date(&apos;2018-09-10 13:23&apos;) =1536556980000iOS: +new Date(&apos;2018-09-10 13:23&apos;) = NANios手机上不能正确转换这种格式，将-改为/就可以了，如：Android: +new Date(&apos;2018/09/10 13:23&apos;) =1536556980000iOS: +new Date(&apos;2018/09/10 13:23&apos;) = 1536556980000","categories":[{"name":"前端","slug":"前端","permalink":"blog.lookpeakfans.xyz/categories/前端/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"blog.lookpeakfans.xyz/tags/小程序/"}]},{"title":"PDF.js预览文件","slug":"preview-pdf","date":"2018-07-21T16:00:00.000Z","updated":"2018-09-12T09:46:42.000Z","comments":true,"path":"2018/07/22/preview-pdf/","link":"","permalink":"blog.lookpeakfans.xyz/2018/07/22/preview-pdf/","excerpt":"","text":"网上找到很多前端实现文件预览方法，但都无法解决我的问题，产品需求中将文件上传到腾讯云的对象存储，返回一个URL，这个URL无法在网页中预览，浏览器将这个URL直接本地下载文件（下载文件下面说）,最后只能用PDF.js，这是一个开源的js库，直接将PDF文件渲染成canvas，PDF.js框架的魅力所在，为其为HTML5实现的，无需任何本地支持，而且对浏览器的兼容性也是比较好，要求只有一个：浏览器支持HTML5就好了！（不过对于低版本的IE，就只能节哀了！）.不多说，直接贴代码(angular5.0开发):在线演示地址：http://mozilla.github.com/pdf.js/web/viewer.htmlDemo地址：http://mozilla.github.io/pdf.js/examples/PDF.js可在官网下载 地址：http://mozilla.github.io/pdf.js/方案一(需要翻墙)：&lt;canvas id=\"the-canvas\" class=\"the-canvas\" style=\"position: absolute; left: 0; right: 0; margin: auto;\"&gt;&lt;/canvas&gt;&lt;div class=\"m-t\" style=\"position: fixed; right: 40px;\"&gt; &lt;button id=\"prev\" nz-button class=\"m-r-md\"&gt;&lt;i class=\"anticon anticon-left\"&gt;&lt;/i&gt;Previous&lt;/button&gt; &lt;span class=\"m-r-md\"&gt;Page: &lt;span id=\"page_num\"&gt;&lt;/span&gt; / &lt;span id=\"page_count\"&gt;&lt;/span&gt;&lt;/span&gt; &lt;button id=\"next\" nz-button&gt;Next&lt;i class=\"anticon anticon-right\"&gt;&lt;/i&gt;&lt;/button&gt;&lt;/div&gt;通过按钮控制页面加载previewPDF(url) &#123; // url 为PDF文件的链接地址; const vm = this; const pdfjsLib = window['pdfjs-dist/build/pdf']; pdfjsLib.GlobalWorkerOptions.workerSrc = '//mozilla.github.io/pdf.js/build/pdf.worker.js'; let pdfDoc = null, pageNum = 1, pageRendering = false, pageNumPending = null, scale = 1.6, canvas = vm.el.nativeElement.querySelector('.the-canvas'), ctx = canvas['getContext']('2d'); function renderPage(num) &#123; pageRendering = true; pdfDoc.getPage(num).then(function (page) &#123; const viewport = page.getViewport(scale); canvas['height'] = viewport.height; canvas['width'] = viewport.width; const renderContext = &#123; canvasContext: ctx, viewport: viewport &#125;; const renderTask = page.render(renderContext); renderTask.promise.then(function () &#123; pageRendering = false; if (pageNumPending !== null) &#123; renderPage(pageNumPending); pageNumPending = null; &#125; &#125;); &#125;); vm.el.nativeElement.querySelector('#page_num').textContent = num; &#125; function queueRenderPage(num) &#123; if (pageRendering) &#123; pageNumPending = num; &#125; else &#123; renderPage(num); &#125; &#125; function onPrevPage() &#123; if (pageNum &lt;= 1) &#123; return; &#125; pageNum--; queueRenderPage(pageNum); &#125; vm.el.nativeElement.querySelector('#prev').addEventListener('click', onPrevPage); function onNextPage() &#123; if (pageNum &gt;= pdfDoc.numPages) &#123; return; &#125; pageNum++; queueRenderPage(pageNum); &#125; vm.el.nativeElement.querySelector('#next').addEventListener('click', onNextPage); pdfjsLib.getDocument(url).then(function (pdfDoc_) &#123; pdfDoc = pdfDoc_; vm.el.nativeElement.querySelector('#page_count').textContent = pdfDoc.numPages; renderPage(pageNum); &#125;); &#125;结果如下图:what!，页面太丑了……与官方的预览页面相比的确有那么一丢丢不满意，没事，下面来说使用本地预览PDF，与官方页面一样哦~~预览一存在一个问题：访问网络需要支持翻墙（啥！还要翻墙，糗~~）。项目上线后大量用户反映无法预览PDF，归根结底就是许多用户根本没有翻墙，被老板狠批一顿，啪啪打脸！！！既然不满足需求，改呗！代码如下：方案二(不需要翻墙)：方案二是不需要访问线上资源，本地渲染PDF展示。下载源码: https://github.com/lishaoh/PDF.jsstep1:将源码加入到项目中，目录如下：在web目录下有viewer.js文件step2:在viewer.js 里面做如下修改：var DEFAULT_URL = ''; // 将默认PDF路径路径置为空step3:在按钮点击事件中调用window.open()&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=referrer content=never&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt;&lt;/head&gt;&lt;body&gt;&lt;button onclick=\"preview()\"&gt;PDF预览&lt;/button&gt;&lt;/body&gt;&lt;script&gt; function preview() &#123; console.log('test'); var pdf = 'pdf的URL'; window.open('./js/pdf/web/viewer.html?file=' + pdf, 'PDF'); &#125;&lt;/script&gt;&lt;/html&gt;至此OK了，老板再也不用当心用户没有翻墙了~~~截图如下：","categories":[{"name":"前端","slug":"前端","permalink":"blog.lookpeakfans.xyz/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"blog.lookpeakfans.xyz/tags/JS/"}]},{"title":"Canvas实现图片压缩上传","slug":"compress-image","date":"2018-07-19T16:00:00.000Z","updated":"2018-09-12T08:14:03.000Z","comments":true,"path":"2018/07/20/compress-image/","link":"","permalink":"blog.lookpeakfans.xyz/2018/07/20/compress-image/","excerpt":"","text":"接到产品需求，问能不能将前端上传的图片压缩？像移动端上传图片，一般都是超清、高清图片，大小也有10M，甚至一张图片大小有15M左右，这样大的图片上传到腾讯云或者阿里云（没使用服务器上传图片）一方面上传速度慢，影响体验，另一方面体积太大占空间，图片压缩避免了，网上搜到了很多这方面介绍的网址，大多数都是用canvas来实现（不说了，马上开干）！。实现过程 (10M =&gt; 200k左右)1. 图片裁剪大体的思路是将图片抽样显示在canvas上，然后用通过canvas.toDataURL方法得到base64字符串来实现压缩。上代码！！！const file: &#123;&#125; = e.target.files[0]; // 通过input元素触发的change事件const reader = new FileReader(),img = new Image();// 缩放图片需要的canvasconst canvas = document.createElement('canvas');const context = canvas.getContext('2d');reader.readAsDataURL(file);// base64地址图片加载完毕后img.onload = function () &#123; // 图片原始尺寸 const originWidth = this['width']; const originHeight = this['height']; // 最大尺寸限制 const maxWidth = 750, maxHeight = 400; // 目标尺寸 let targetWidth = originWidth, targetHeight = originHeight; // 图片尺寸超过750x400的限制 if (originWidth &gt; maxWidth || originHeight &gt; maxHeight) &#123; if (originWidth / originHeight &gt; maxWidth / maxHeight) &#123; // 更宽，按照宽度限定尺寸 targetWidth = maxWidth; targetHeight = Math.round(maxWidth * (originHeight / originWidth)); &#125; else &#123; targetHeight = maxHeight; targetWidth = Math.round(maxHeight * (originWidth / originHeight)); &#125; &#125; // canvas对图片进行缩放 canvas.width = targetWidth; canvas.height = targetHeight; // 清除画布 context.clearRect(0, 0, targetWidth, targetHeight); // 图片压缩 context.drawImage(img, 0, 0, targetWidth, targetHeight); // canvas转为blob并上传 // * 很多PC、手机浏览器不支持toBlob方法，如Safari* // 不推荐使用toBlob方法 // canvas.toBlob(function($Blob) &#123; // &#125;) const dataUrl = canvas.toDataURL('image/jpeg'); updateImgForBase64(dataUrl);&#125;reader.onload = function (e) &#123; img.src = e.target['result'];&#125;;2. 上传到腾讯云项目中图片是保存在腾讯云中，这里就需要用到腾讯JavaScript SDK，按照SDK文档去新建存储桶获取Bucket、Region，直接上代码：updateImgForBase64(img: string, type: string = 'jpeg'): Promise&lt;any&gt; &#123; const vm = this; const storeAs = `avatar/$&#123;new Date().getTime()&#125;-$&#123;this.guid()&#125;.$&#123;type&#125;`; const dataURLtoFile: Function = (dataurl, filename) =&gt; &#123; const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1]; const bstr = atob(arr[1]); let n = bstr.length; const u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new File([u8arr], filename, &#123;type: mime&#125;); &#125;; const file = dataURLtoFile(img, type); // function getBlobBydataURI(dataURI, type) &#123; // var binary = atob(dataURI.split(',')[1]); // var array = []; // for (var i = 0; i &lt; binary.length; i++) &#123; // array.push(binary.charCodeAt(i)); // &#125; // return new Blob([new Uint8Array(array)], &#123;type: type&#125;); // &#125; // // /** // * 上传 formData.append(\"files\", $Blob, storeAs);对iOS系统不支持 // */ // //base64 转 blob // let $Blob = getBlobBydataURI(img, 'image/jpeg'); // let formData = new FormData(); // let storeAs = `documents/$&#123;new Date().getTime()&#125;-$&#123;this.guid()&#125;.$&#123;type&#125;`; // formData.append(\"files\", $Blob, storeAs); //组建XMLHttpRequest 上传文件 return new Promise((resolve, reject) =&gt; &#123; this.cos.sliceUploadFile(&#123; Bucket: 'your bucket', Region: 'your region', Key: storeAs, Body: file &#125;, function (err, data) &#123; if (err) &#123; reject(JSON.stringify(err)); &#125; else &#123; resolve(url); &#125; &#125;); &#125;) &#125;","categories":[{"name":"前端","slug":"前端","permalink":"blog.lookpeakfans.xyz/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"blog.lookpeakfans.xyz/tags/JS/"}]},{"title":"前端实现在线预览pdf、word、xls、ppt等文件","slug":"preview-file","date":"2018-07-13T16:00:00.000Z","updated":"2018-09-12T08:37:21.000Z","comments":true,"path":"2018/07/14/preview-file/","link":"","permalink":"blog.lookpeakfans.xyz/2018/07/14/preview-file/","excerpt":"","text":"1、前端实现pdf文件在线预览功能方式一: 通过a标签href属性实现pdf文件理论上可以在浏览器直接打开预览但是需要打开新页面。在仅仅是预览pdf文件且UI要求不高的情况下可以直接通过a标签href属性实现预览&lt;a href=\"文档地址\"&gt;&lt;/a&gt;方式二: 通过jquery插件jquery.media.js实现这个插件可以实现pdf预览功能（包括其他各种媒体文件）但是对word等类型的文件无能为力。实现方式：&lt;script type=\"text/javascript\" src=\"jquery-1.7.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"jquery.media.js\"&gt;&lt;/script&gt;html结构： &lt;body&gt; &lt;div id=\"handout_wrap_inner\"&gt;&lt;/div&gt; &lt;/body&gt;调用方式：&lt;script type=\"text/javascript\"&gt; $('#handout_wrap_inner').media(&#123; width: '100%', height: '100%', autoplay: true, src:'http://storage.xuetangx.com/public_assets/xuetangx/PDF/PlayerAPI_v1.0.6.pdf', &#125;); &lt;/script&gt;方式三: 直接通过页面内嵌iframe$(\"&lt;iframe src='\"+ this.previewUrl +\"' width='100%' height='362px' frameborder='1'&gt;\").appendTo($(\".video-handouts-preview\"));此外还可以在iframe标签之间提供一个提示类似这样&lt;iframe :src=\"previewUrl\" width=\"100%\" height=\"100%\"&gt;This browser does not support PDFs. Please download the PDF to view it: &lt;a :href=\"previewUrl\"&gt;Download PDF&lt;/a&gt;&lt;/iframe&gt;方式四: 通过标签嵌入内容&lt;embed :src=\"previewUrl\" type=\"application/pdf\" width=\"100%\" height=\"100%\"&gt;此标签h5特性中包含四个属性：高、宽、类型、预览文件src！与&lt; iframe &gt; &lt; / iframe &gt; 不同，这个标签是自闭合的的，也就是说如果浏览器不支持PDF的嵌入，那么这个标签的内容什么都看不到！方式五: 标签和iframe使用差别较小&lt;object :src=\"previewUrl\" width=\"100%\" height=\"100%\"&gt;This browser does not support PDFs. Please download the PDF to view it: &lt;a :href=\"previewUrl\"&gt;Download PDF&lt;/a&gt;&lt;/object&gt;除方式二以外其他都是直接通过标签将内容引入页面实现预览方式六: PDFObjectPDFObject实际上也是通过标签实现的直接上代码&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Show PDF&lt;/title&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;script type=\"text/javascript\" src='pdfobject.min.js'&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; html,body,#pdf_viewer&#123; width: 100%; height: 100%; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"pdf_viewer\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; if(PDFObject.supportsPDFs)&#123; // PDF嵌入到网页 PDFObject.embed(\"index.pdf\", \"#pdf_viewer\" ); &#125; else &#123; location.href = \"/canvas\"; &#125; // 还可以通过以下代码进行判断是否支持PDFObject预览 if(PDFObject.supportsPDFs)&#123; console.log(\"Yay, this browser supports inline PDFs.\"); &#125; else &#123; console.log(\"Boo, inline PDFs are not supported by this browser\"); &#125;&lt;/script&gt;&lt;/html&gt;方式七: PDF.js (简单粗暴)PDF.js可以实现在html下直接浏览pdf文档，是一款开源的pdf文档读取解析插件，非常强大，能将PDF文件渲染成Canvas。PDF.js主要包含两个库文件，一个pdf.js和一个pdf.worker.js，一个负责API解析，一个负责核心解析。2、word、xls、ppt文件在线预览功能word、ppt、xls文件实现在线预览的方式比较简单可以直接通过调用微软的在线预览功能实现 (预览前提：资源必须是公共可访问的)&lt;iframe src='https://view.officeapps.live.com/op/view.aspx?src=http://storage.xuetangx.com/public_assets/xuetangx/PDF/1.xls' width='100%' height='100%' frameborder='1'&gt;&lt;/iframe&gt;/*src就是要实现预览的文件地址*//*具体文档看这微软接口文档*//*补充：google的文档在线预览实现同微软（资源必须是公共可访问的）*/&lt;iframe :src=\"'https://docs.google.com/viewer?url=\"fileurl\"&gt;&lt;/iframe&gt;3、word文件XDOC可以实现预览以DataURI表示的DOC文档，此外XDOC还可以实现文本、带参数文本、html文本、json文本、公文等在线预览，具体实现方法请看官方文档下面这种方式可以实现快速预览word但是对文件使用的编辑器可能会有一些限制&lt;a href=\"http://www.xdocin.com/xdoc?_func=to&amp;amp;_format=html&amp;amp;_cache=1&amp;amp;_xdoc=http://www.xdocin.com/demo/demo.docx\" target=\"_blank\" rel=\"nofollow\"&gt;XDOC&lt;/a&gt;4、excel文件目前excel文件已经有了类似pdf.js那样的解析sheet.js总结1、免费纯前端方式实现在线预览word、excel、ppt最优选择微软在线预览（不可编辑）2、利用后端将文件转为图片，前端以图片形式预览（可行方案）3、购买在线预览服务例如百度DOC文档服务、永中、I DOC VIEW等转载","categories":[{"name":"前端","slug":"前端","permalink":"blog.lookpeakfans.xyz/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"blog.lookpeakfans.xyz/tags/JS/"}]},{"title":"微信JSSDK遇到的那些坑","slug":"wx-sdk","date":"2018-06-19T16:00:00.000Z","updated":"2018-09-12T08:12:00.000Z","comments":true,"path":"2018/06/20/wx-sdk/","link":"","permalink":"blog.lookpeakfans.xyz/2018/06/20/wx-sdk/","excerpt":"","text":"作为一个前端开发者，相信很多同道中人在微信公众号的开发中被坑的很惨，我也分享开发过程中的一点点经验给大家，可以减少很多弯路。由于项目需要，前端开发使用的是angular4.0技术，微信开发工具v1.02。前端开发公众号最坑的就是微信JSSDK的使用，前面坑路漫漫，我还得一步一步趟过去。JSSDK使用报错1. config:invalid signature一直报这个错误&nbsp;&nbsp;&nbsp;&nbsp;建议：首先查看微信官方网站给出的解决方案.链接 获取access_token&nbsp;&nbsp;&nbsp;&nbsp;建议按如下顺序查找错误：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.确认签名算法正确，可用 http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign 页面工具进行校验。也就是你自己后台生成签名要和微信校验算法生成的签名一致才可以（可能大小写不同）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.确认config中nonceStr（js中驼峰标准大写S）, timestamp与用以签名中的对应noncestr, timestamp一致。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.确认url是页面完整的url(请在当前页面alert(location.href.split(‘#’)[0])确认)，包括’http(s)://‘部分，以及’？’后面的GET参数部分,但不包括’#’hash后面的部分。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.确认 config 中的 appid 与用来获取 jsapi_ticket 的 appid 一致。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.确保一定缓存access_token和jsapi_ticket。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.出现问题的原因是参与签名的URL地址不正确，需要动态获取当前页面完整的URL地址（包括?后面的参数，但不能包含#号），如若URL地址为：http://www.xxx.xxx/payment/wxpay/jspay?oid=xxxx&amp;attr=xxxx#wechat，那么完整的URL地址应该是截取#号之前的部份。为什么会出现#号呢？因为你的URL在被分享到朋友圈等微信系统自动会添加一些参数。&nbsp;&nbsp;&nbsp;&nbsp;PS：这里有一个大坑，就是Android和iOS对于当前页面的URL有不同的理解，iOS微信JSSDK授权易出错，但是筛选页面后又OK了，Android每次授权是OK的，具体介绍看这里。原因就是因为iOS和Android对URL的识别机制不同：Android每次进行新页面时当前URL也是最新的，而iOS每次进去新页面时实际URL是第一次进入应用的URL，刷新之后当前页面URL就是最新URL。解决办法： 在home页判断当前平台是否为iOS，若为iOS，此时通过wx.config()授权，获取直接通过window.location.href链接跳转来改变当前页面URL2. permission denied权限错误&nbsp;&nbsp;&nbsp;&nbsp;首先查看微信给出的错误说明：该公众号没有权限使用这个JSAPI（部分接口需要认证之后才能使)。&nbsp;&nbsp;&nbsp;&nbsp;说明：只要通过了公众号认证，都不会有问题。&nbsp;&nbsp;&nbsp;&nbsp;检查对象：如果出现这个说明程序上基本上不会有问题 微信后台已经返回了数据。&nbsp;&nbsp;&nbsp;&nbsp;第一、要检查 你的config 文件中相应的 jsApiList数组中是否包含了该接口。wx.config(&#123; debug: false, appId: '', timestamp:'', nonceStr:'', signature:'', jsApiList: [ 'checkJsApi', 'onMenuShareTimeline', 'hideOptionMenu' ... ]&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"blog.lookpeakfans.xyz/categories/前端/"}],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"blog.lookpeakfans.xyz/tags/微信公众号/"}]},{"title":"微信公众号本地调试小技巧","slug":"ngrok","date":"2018-06-11T16:00:00.000Z","updated":"2018-09-12T08:11:35.000Z","comments":true,"path":"2018/06/12/ngrok/","link":"","permalink":"blog.lookpeakfans.xyz/2018/06/12/ngrok/","excerpt":"","text":"本地调试是公众号开发过程中不可缺少的步骤，我们不可能每次开发都上传到服务器再用微信去查看本地效果，这样一方面效率低，另一方面存在一定的风险性。那么有没有什么办法能够让开发者本地调试代码呢，答案是有的，网上搜出了很多方法，比如ngrok、花生壳、natapp.cn等工具，下面介绍的是ngrok，其他的嫌麻烦。ngrok使用1. 为什么要用ngrok&nbsp;&nbsp;&nbsp;&nbsp;在微信开发的时候需要填写与微信服务器相连接的url才能授权，这个url必须是外网域名，也就是说我们需要在这个外网域名对应的ip服务器上做开发，而没办法本地开发调试所以用ngrok获得一个外网域名 这个外网域名实际访问的是本地主机这样把此外网域名填入到微信需要的外网url里就可以在本地开发调试了。2.使用ngrok&nbsp;&nbsp;&nbsp;&nbsp;首先到官网下载ngrok，然后注册一个ngrok帐号拿到token，这个token自定义域名的时候使用，具体看这里。我本人使用的MAC，需到ngrok目录下执行命令这时候ngrok已经生成了一个外网域名http://4f75fc79.ngrok.io访问本机localhost:80浏览器里直接访问http://4f75fc79.ngrok.io就可以访问本地。现在外网有了，就可以开始授权了。为了避免和线上冲突，我注册了一个微信公众号开发者测试号，已经能够调用微信开放的大多数JS接口了。创建公众号测试帐号方法可以自行百度.此处有一个坑，网上很多都说这里的token是随便写的，的确，但是作为一个前端开发者，在没有后端资源情况下随便填写的token总是报token无效错误，这是因为保存修改时微信会向填写的URL发送一个验证请求，验证token是否有效，但是我们不知道token是多少，现在如何做呢？我有node.js爸爸，还怕什么呢，我们可以本地起一个服务来监听微信请求的URL，上面说到微信此时会发起一个get请求到http://4f75fc79.ngrok.io那我就本地写一个服务来监听，只要服务里的token和修改的一致不就可以匹配了吗？说干就干，直接上代码var PORT=80; //监听80端口号var http=require('http'); var qs=require('qs');var TOKEN='token'; //必须与测试号所填写的Token相同function checkSignature(params,token)&#123; var key=[token,params.timestamp,params.nonce].sort().join(''); //将token （自己设置的） 、timestamp（时间戳）、nonce（随机数）三个参数进行字典排序 var sha1=require('crypto').createHash('sha1'); //将上面三个字符串拼接成一个字符串再进行sha1加密 sha1.update(key); return sha1.digest('hex') ==params.signature; //将加密后的字符串与signature进行对比，若成功，返回echostr&#125;var server=http.createServer(function (request,response) &#123; var query=require('url').parse(request.url).query; var params=qs.parse(query); console.log(params); console.log(\"token :\",TOKEN); if(!checkSignature(params,TOKEN))&#123; //如果签名不对，结束请求并返回 response.end('signature fail'); &#125; if (request.method == \"GET\") &#123; //如果请求是GET，返回echostr用于通过服务器有效校验 response.end(params.echostr); &#125;else&#123; //否则是微信给开发者服务器的POST请求 var postdata=''; request.addListener(\"data\",function(postchunk)&#123; postdata+=postchunk; &#125;); //获取到了POST数据 request.addListener(\"end\",function()&#123; console.log(postdata); response.end('success '); &#125;); &#125;&#125;);server.listen(PORT, function () &#123; console.log('Server running at port:'+PORT);&#125;);微信发起的请求直接到我们本地，那还不是我想怎么玩就怎么玩，嘿嘿嘿！具体操作看这里修改接口配置成功后就可以调用测试号里面的所有js接口了，实现本地调试微信公众号不再是奢望！！！","categories":[{"name":"工具","slug":"工具","permalink":"blog.lookpeakfans.xyz/categories/工具/"}],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"blog.lookpeakfans.xyz/tags/微信公众号/"}]},{"title":"CSS实现文字滚动，类型京东商城公告栏","slug":"css-roll","date":"2018-04-24T16:00:00.000Z","updated":"2018-09-12T08:10:06.000Z","comments":true,"path":"2018/04/25/css-roll/","link":"","permalink":"blog.lookpeakfans.xyz/2018/04/25/css-roll/","excerpt":"","text":"实现文字滚动，第一时间想用swiper进行，但是需求功能较少，不需要引用外部swiper.js，直接用CSS的animate属性实现文字滚动，2秒滚动一次，实现如下:&lt;div class=\"notice\"&gt; &lt;ul&gt; &lt;li&gt;第1条公告第1条公告第1条公告第1条公告第1条公告第1条公告&lt;/li&gt; &lt;li&gt;第2条公告第2条公告第2条公告第2条公告第2条公告第2条公告&lt;/li&gt; &lt;li&gt;第3条公告第3条公告第3条公告第3条公告第3条公告第3条公告&lt;/li&gt; &lt;li&gt;第4条公告第4条公告第4条公告第4条公告第4条公告第4条公告&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;div,ul,li&#123;margin: 0;padding: 0&#125;/*先初始化一下默认样式*/.notice &#123; width: 300px;/*单行显示，超出隐藏*/ height: 35px;/*固定公告栏显示区域的高度*/ padding: 0 30px; background-color: #b3effe; overflow: hidden;&#125;.notice ul li &#123; list-style: none; line-height: 35px; /*以下为了单行显示，超出隐藏*/ display: block; white-space: nowrap; text-overflow: ellipsis; overflow: hidden;&#125;function noticeUp(obj,top,time) &#123; $(obj).animate(&#123; marginTop: top &#125;, time, function () &#123; $(this).css(&#123;marginTop:\"0\"&#125;).find(\":first\").appendTo(this); &#125;)&#125; setInterval(\"noticeUp('.notice ul','-35px',500)\", 2000);","categories":[{"name":"前端","slug":"前端","permalink":"blog.lookpeakfans.xyz/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"blog.lookpeakfans.xyz/tags/CSS/"}]}]}